// Generated by dts-bundle v0.7.3

declare module 'tsjson' {
    import * as errors from 'tsjson/errors/decoding/decoding-error';
    import { Reader } from 'tsjson/readers/reader.interface';
    import { OptionalReader } from 'tsjson/readers/abstract-reader';
    import { PrimitiveReaders } from 'tsjson/readers/primitive-readers';
    import { ArrayReader } from 'tsjson/readers/array-reader';
    import { ExtractReader } from 'tsjson/readers/extract-reader';
    import { EnumReader } from 'tsjson/readers/enum-reader';
    import { EmptyObjectConstructor } from 'tsjson/readers/object-reader';
    import { MapReader } from 'tsjson/readers/map-reader';
    import { AnyReader } from 'tsjson/readers/any-reader';
    export { Reader } from 'tsjson/readers/reader.interface';
    export { AbstractReader } from 'tsjson/readers/abstract-reader';
    export { Types } from 'tsjson/jstypes';
    export namespace TsJson {
        namespace Error {
            type DecodingError = errors.DecodingError;
        }
        const number: PrimitiveReaders.NumberReader;
        const string: PrimitiveReaders.StringReader;
        const boolean: PrimitiveReaders.BooleanReader;
        const anything: AnyReader;
        function optional<T>(reader: Reader<T>): OptionalReader<T>;
        function array<T>(reader: Reader<T>): ArrayReader<T>;
        function extract<T>(property: string, reader: Reader<T>): ExtractReader<T>;
        function enumeration(): EnumReader<never>;
        function map<T>(valueReader: Reader<T>): MapReader<T>;
        function obj(): EmptyObjectConstructor;
    }
}

declare module 'tsjson/errors/decoding/decoding-error' {
    export interface ArrayChildError {
        type: 'array-error';
        index: number;
        error: DecodingError;
    }
    export namespace ArrayChildError {
        function create(index: number, error: DecodingError): ArrayChildError;
    }
    export interface ErrorGroup {
        type: 'error-group';
        errors: DecodingError[];
        value: any;
    }
    export namespace ErrorGroup {
        function create(value: any, errors: DecodingError[]): ErrorGroup;
    }
    export interface InconsistentTypesError {
        type: 'inconsistent-types';
        found: string[];
        value: any;
    }
    export namespace InconsistentTypesError {
        function create(value: any, found: string[]): InconsistentTypesError;
    }
    export interface InvalidTypeError {
        type: 'invalid-type';
        expected: string;
        actual: string;
        value: any;
        error: DecodingError | null;
    }
    export namespace InvalidTypeError {
        function create(value: any, expected: string, actual: string, forwarded?: DecodingError): InvalidTypeError;
    }
    export type DecodingError = InvalidTypeError | InconsistentTypesError | ArrayChildError | ErrorGroup;
}

declare module 'tsjson/readers/reader.interface' {
    import { DecodingError } from 'tsjson/errors/decoding/decoding-error';
    import { Result } from 'tsjson/result/result';
    import { Types } from 'tsjson/jstypes';
    export interface Reader<T> {
        expectedType: Types.Type;
        read(obj: any): Result<T, DecodingError>;
    }
}

declare module 'tsjson/readers/abstract-reader' {
    import { DecodingError } from 'tsjson/errors/decoding/decoding-error';
    import { Result } from 'tsjson/result/result';
    import { Reader } from 'tsjson/readers/reader.interface';
    import { Types } from 'tsjson/jstypes';
    export abstract class AbstractReader<T> implements Reader<T> {
        abstract expectedType: Types.Type;
        abstract read(obj: any): Result<T, DecodingError>;
        withDefault(value: T): DefaultReader<T>;
        asOptional(): OptionalReader<T>;
        or<S>(other: Reader<S>): OrReader<T, S>;
    }
    export class DefaultReader<T> extends AbstractReader<T> implements Reader<T> {
        expectedType: Types.Type;
        constructor(reader: Reader<T>, defaultValue: T);
        read(obj: any): Result<T, DecodingError>;
    }
    export class OrReader<A, B> extends AbstractReader<A | B> implements Reader<A | B> {
        expectedType: Types.Type;
        constructor(readerA: Reader<A>, readerB: Reader<B>);
        read(obj: any): Result<A | B, DecodingError>;
    }
    export class OptionalReader<T> extends DefaultReader<T | null> {
        constructor(reader: Reader<T>);
    }
}

declare module 'tsjson/readers/primitive-readers' {
    import { DecodingError } from 'tsjson/errors/decoding/decoding-error';
    import { Result } from 'tsjson/result/result';
    import { AbstractReader } from 'tsjson/readers/abstract-reader';
    import { Reader } from 'tsjson/readers/reader.interface';
    import { Types } from 'tsjson/jstypes';
    export namespace PrimitiveReaders {
        class BooleanReader extends AbstractReader<boolean> implements Reader<boolean> {
            expectedType: Types.BooleanType;
            read(obj: any): Result<boolean, DecodingError>;
        }
        class StringReader extends AbstractReader<string> implements Reader<string> {
            expectedType: Types.StringType;
            read(obj: any): Result<string, DecodingError>;
        }
        class NumberReader extends AbstractReader<number> implements Reader<number> {
            expectedType: Types.NumberType;
            read(obj: any): Result<number, DecodingError>;
        }
    }
}

declare module 'tsjson/readers/array-reader' {
    import { DecodingError } from 'tsjson/errors/decoding/decoding-error';
    import { Result } from 'tsjson/result/result';
    import { AbstractReader } from 'tsjson/readers/abstract-reader';
    import { Reader } from 'tsjson/readers/reader.interface';
    import { Types } from 'tsjson/jstypes';
    export class ArrayReader<T> extends AbstractReader<T[]> implements Reader<T[]> {
        expectedType: Types.ArrayType;
        constructor(reader: Reader<T>);
        read(obj: any): Result<T[], DecodingError>;
    }
}

declare module 'tsjson/readers/extract-reader' {
    import * as errors from 'tsjson/errors/decoding/decoding-error';
    import { Result } from 'tsjson/result/result';
    import { AbstractReader } from 'tsjson/readers/abstract-reader';
    import { Reader } from 'tsjson/readers/reader.interface';
    import { Types } from 'tsjson/jstypes';
    export class ExtractReader<T> extends AbstractReader<T> implements Reader<T> {
        expectedType: Types.Type;
        constructor(property: string, reader: Reader<T>);
        read(obj: any): Result<T, errors.DecodingError>;
    }
}

declare module 'tsjson/readers/enum-reader' {
    import * as errors from 'tsjson/errors/decoding/decoding-error';
    import { Result } from 'tsjson/result/result';
    import { AbstractReader } from 'tsjson/readers/abstract-reader';
    import { Reader } from 'tsjson/readers/reader.interface';
    import { Types } from 'tsjson/jstypes';
    export class EnumReader<T extends string> extends AbstractReader<T> implements Reader<T> {
        expectedType: Types.Type;
        static create(): EnumReader<never>;
        case<S extends string>(s: S): EnumReader<T | S>;
        read(obj: any): Result<T, errors.DecodingError>;
    }
}

declare module 'tsjson/readers/object-reader' {
    import * as errors from 'tsjson/errors/decoding/decoding-error';
    import { Result } from 'tsjson/result/result';
    import { AbstractReader } from 'tsjson/readers/abstract-reader';
    import { Reader } from 'tsjson/readers/reader.interface';
    import { Types } from 'tsjson/jstypes';
    export interface ObjectConstructorInterface<T extends {}> extends Reader<T> {
        expectedType: Types.Type;
        isEmpty(): this is EmptyObjectConstructor;
        put<S extends string, U>(s: S & string, reader: Reader<U>): ObjectConstructorInterface<{
            [s in S]: U;
        } & T>;
        prop<S extends string, U>(s: S & string, reader: Reader<U>): ObjectConstructorInterface<{
            [s in S]: U;
        } & T>;
        read(obj: any): Result<T, errors.DecodingError>;
    }
    export class EmptyObjectConstructor extends AbstractReader<{}> implements ObjectConstructorInterface<{}> {
        expectedType: Types.ObjectType;
        isEmpty(): this is EmptyObjectConstructor;
        put<S extends string, U>(s: S, reader: Reader<U>): ObjectConstructorInterface<{
            [s in S]: U;
        } & {}>;
        prop<S extends string, U>(s: S, reader: Reader<U>): ObjectConstructorInterface<{
            [s in S]: U;
        } & {}>;
        read(): Result<{}, errors.DecodingError>;
    }
    export class ObjectConstructor<S extends string, U, Base> implements ObjectConstructorInterface<{
        [s in S]: U;
    } & Base> {
        expectedType: Types.Type;
        constructor(property: S, reader: Reader<U>, base: ObjectConstructorInterface<Base>);
        isEmpty(): this is EmptyObjectConstructor;
        put<NewS extends string, NewU>(s: NewS, reader: Reader<NewU>): ObjectConstructorInterface<{
            [s in NewS]: NewU;
        } & {
            [s in S]: U;
        } & Base>;
        prop<NewS extends string, NewU>(s: NewS, reader: Reader<NewU>): ObjectConstructorInterface<{
            [s in NewS]: NewU;
        } & {
            [s in S]: U;
        } & Base>;
        read(obj: any): Result<{
            [s in S]: U;
        } & Base, errors.DecodingError>;
    }
}

declare module 'tsjson/readers/map-reader' {
    import { DecodingError } from 'tsjson/errors/decoding/decoding-error';
    import { Result } from 'tsjson/result/result';
    import { Reader } from 'tsjson/readers/reader.interface';
    import { Types } from 'tsjson/jstypes';
    export class MapReader<T> implements Reader<{
        [k: string]: T;
    }> {
        expectedType: Types.Type;
        constructor(valueReader: Reader<T>);
        read(obj: any): Result<{
            [k: string]: T;
        }, DecodingError>;
    }
}

declare module 'tsjson/readers/any-reader' {
    import * as errors from 'tsjson/errors/decoding/decoding-error';
    import { Reader } from 'tsjson/readers/reader.interface';
    import { AbstractReader } from 'tsjson/readers/abstract-reader';
    import { Types } from 'tsjson/jstypes';
    import { Result } from 'tsjson/result/result';
    export class AnyReader extends AbstractReader<any> implements Reader<any> {
        expectedType: Types.AnyType;
        read(obj: any): Result<any, errors.DecodingError>;
    }
}

declare module 'tsjson/jstypes' {
    export function quote(s: string): string;
    export namespace Types {
            interface NullType {
                    type: 'null';
            }
            interface StringType {
                    type: 'string';
                    value: null | string;
            }
            interface NumberType {
                    type: 'number';
            }
            interface BooleanType {
                    type: 'boolean';
            }
            interface ArrayType {
                    type: 'array';
                    contained: Type;
            }
            interface ObjectType {
                    type: 'object';
                    spec: null | {
                            [k: string]: Type;
                    };
            }
            interface NamedType {
                    type: 'named';
                    name: string;
            }
            interface AnyType {
                    type: 'any';
            }
            interface MapType {
                    type: 'map';
                    value: Type;
            }
            type NonNullPrimitiveType = StringType | NumberType | BooleanType;
            type NonNullSimpleType = NonNullPrimitiveType | ArrayType | ObjectType | MapType | NamedType;
            type SimpleType = NonNullSimpleType | NullType;
            interface UnionType {
                    type: 'union';
                    types: NonUnionType[];
            }
            interface NullableType {
                    type: 'nullable';
                    subtype: NonNullableNonNullType;
            }
            type NonUnionType = SimpleType | NullableType;
            type NonNullableNonNullType = NonNullSimpleType | UnionType;
            type NonNullableType = SimpleType | UnionType;
            type Type = NonUnionType | NonNullableType | NullType | AnyType;
            function isNull(a: Type): a is NullType;
            function isString(a: Type): a is StringType;
            function isNumber(a: Type): a is NumberType;
            function isBoolean(a: Type): a is BooleanType;
            function isArray(a: Type): a is ArrayType;
            function isObject(a: Type): a is ObjectType;
            function isUnion(a: Type): a is UnionType;
            function isNullable(a: Type): a is NullableType;
            function isMap(a: Type): a is MapType;
            function isNamed(a: Type): a is NamedType;
            function isAny(a: Type): a is AnyType;
            function toString(a: Type): string;
            const Any: AnyType;
            const Null: NullType;
            const Number: NumberType;
            const String: StringType;
            function StringValue(value: string): StringType;
            const Boolean: BooleanType;
            function Map(contained: Type): MapType;
            function Nullable(subtype: Type): NullableType | NullType | AnyType;
            function Array(contained: Type): ArrayType;
            function Object(spec?: null | {
                    [k: string]: Type;
            }): ObjectType;
            function Named(name: string): NamedType;
            function Union(types: Type[]): UnionType | NullableType | AnyType;
            function equals(a: Type, b: Type): boolean;
            /**
                * This is used for building up a type. It's the equivalent of `&` in TypeScript.
                * This should return null for everything except objects (since it's not
                * possible to have a union of anything but objects).
                */
            function combine(a: Type, b: Type): Type | null;
            /**
                * This returns a type that will accept either this type or the other type
                * when it is assigned to the resulting type. This one should never fail,
                * since we can always default to a union type.
                */
            function unify(a: Type, b: Type): Type;
            function infer(obj: any): Type;
    }
}

declare module 'tsjson/result/result' {
    import { Result as R } from 'tsjson/result/interface';
    export type Result<Success, Failure> = R<Success, Failure>;
    export namespace Result {
        function success<T, E>(value: T): Result<T, E>;
        function failure<T, E>(value: E): Result<T, E>;
        function all<T, E>(results: Result<T, E>[]): Result<T[], E[]>;
    }
}

declare module 'tsjson/result/interface' {
    export interface Result<Success, Failure> {
        type: 'success' | 'failure';
        isSuccess(): this is ResultSuccess<Success, Failure>;
        isFailure(): this is ResultFailure<Success, Failure>;
        assertSuccess(): Success;
        assertFailure(): Failure;
        map<Output>(success: (value: Success) => Output, failure: (value: Failure) => Output): Output;
        flatMap<OutSuccess, OutFailure>(success: (value: Success) => Result<OutSuccess, OutFailure>, failure: (error: Failure) => Result<OutSuccess, OutFailure>): Result<OutSuccess, OutFailure>;
        mapSuccess<OutSuccess>(f: (value: Success) => OutSuccess): Result<OutSuccess, Failure>;
        mapFailure<OutFailure>(f: (value: Failure) => OutFailure): Result<Success, OutFailure>;
    }
    export interface ResultSuccess<T, E> extends Result<T, E> {
        type: 'success';
        value: T;
    }
    export interface ResultFailure<T, E> extends Result<T, E> {
        type: 'failure';
        error: E;
    }
}

